"""
Module: collatz
Package: math_research.sequences

Description:
    Implementation of the Collatz sequence with optimizations including "long step"
    computation. The Collatz conjecture states that starting from any positive integer,
    repeatedly applying the rules (n/2 if even, 3n+1 if odd) will eventually reach 1.
    This module includes both standard and optimized implementations.

Author: MoniGarr
Author Email: monigarr@MoniGarr.com
Author Website: MoniGarr.com

Author Research Interests:
    - AI/ML Research and Development
    - Extended Reality (XR) Applications
    - 3D Graphics and Visualization
    - Robotics and Autonomous Systems
    - Computer Vision
    - Navigation Systems
    - Natural Language Processing (NLP)
    - Low Resource Languages (spoken in English communities)

Usage:
    >>> from math_research.sequences import CollatzSequence
    >>> seq = CollatzSequence(start=27)
    >>> sequence = seq.generate()
    >>> long_step = seq.compute_long_step(27)
    >>> print(f"k={long_step['k']}, k'={long_step['k_prime']}")

Dependencies:
    - math_research.sequences.base
    - typing (standard library)

Version: 0.1.0
Last Modified: 2025-01-09
License: MIT

Notes:
    The "long step" optimization combines consecutive (3n+1)/2 and n/2 operations
    for efficiency. This is based on the observation that if n is odd, 3n+1 is even,
    so it will immediately be divided by 2.
"""

from typing import Dict, Tuple, Optional, List
from math_research.sequences.base import BaseSequence


class CollatzSequence(BaseSequence):
    """
    Collatz sequence generator with long step optimization.
    
    The Collatz sequence is generated by the rule:
    - If n is even: n → n/2
    - If n is odd: n → (3n+1)/2 (optimized long step)
    
    The long step combines the odd transformation (3n+1) and immediate division by 2,
    since 3n+1 is always even when n is odd.
    """
    
    def __init__(
        self,
        start: int,
        max_iterations: int = 1000000,
        use_long_step: bool = True,
    ):
        """
        Initialize a Collatz sequence generator.
        
        Args:
            start: Starting value (must be positive)
            max_iterations: Maximum number of iterations
            use_long_step: If True, use optimized long step computation
        """
        if start <= 0:
            raise ValueError("start must be a positive integer")
        
        super().__init__(
            start=start,
            max_iterations=max_iterations,
            stop_condition=self._collatz_stop_condition,
        )
        self.use_long_step = use_long_step
    
    def _collatz_stop_condition(self, current: int, history: List[int]) -> bool:
        """
        Stop when we reach the 4→2→1 loop.
        
        Args:
            current: Current value
            history: Sequence history
            
        Returns:
            True if we've reached the loop (value is 1)
        """
        return current == 1
    
    def step(self, n: int) -> int:
        """
        Compute the next Collatz value.
        
        Standard implementation: n/2 if even, 3n+1 if odd.
        
        Args:
            n: Current value
            
        Returns:
            Next value in the Collatz sequence
        """
        if n % 2 == 0:
            return n // 2
        else:
            return 3 * n + 1
    
    def long_step(self, n: int) -> Tuple[int, int, int]:
        """
        Compute a long Collatz step for an odd integer.
        
        A long step consists of:
        - k applications of (3n+1)/2 while result is odd
        - k' applications of n/2 while result is even
        
        Args:
            n: Starting odd integer
            
        Returns:
            Tuple of (result, k, k_prime) where:
            - result: Final value after long step
            - k: Number of (3n+1)/2 operations
            - k_prime: Number of n/2 operations
        """
        if n % 2 == 0:
            raise ValueError("long_step requires an odd integer")
        
        k = 0
        k_prime = 0
        current = n
        
        # Apply (3n+1)/2 while result is odd
        while current % 2 == 1:
            current = (3 * current + 1) // 2
            k += 1
        
        # Apply n/2 while result is even
        while current % 2 == 0 and current > 0:
            current = current // 2
            k_prime += 1
            if current == 1:
                break
        
        return current, k, k_prime
    
    def compute_long_step(self, n: int) -> Dict[str, int]:
        """
        Compute long step and return as dictionary.
        
        Args:
            n: Starting odd integer
            
        Returns:
            Dictionary with keys: 'result', 'k', 'k_prime'
        """
        if n % 2 == 0:
            # For even numbers, convert to odd by dividing
            while n % 2 == 0 and n > 1:
                n = n // 2
        
        result, k, k_prime = self.long_step(n)
        return {
            'result': result,
            'k': k,
            'k_prime': k_prime,
            'input': n,
        }
    
    def generate_with_long_steps(
        self,
        max_iterations: Optional[int] = None,
        reset: bool = False,
    ) -> List[Dict[str, int]]:
        """
        Generate sequence using long step optimization.
        
        Args:
            max_iterations: Maximum iterations (overrides instance default)
            reset: If True, reset before generating
            
        Returns:
            List of long step dictionaries
        """
        if reset:
            self.reset()
        
        iterations = max_iterations if max_iterations is not None else self.max_iterations
        long_steps = []
        
        current = self.start
        # Ensure we start with an odd number (divide out factors of 2)
        initial_divisions = 0
        while current % 2 == 0 and current > 1:
            current = current // 2
            initial_divisions += 1
        
        if initial_divisions > 0:
            long_steps.append({
                'input': self.start,
                'result': current,
                'k': 0,
                'k_prime': initial_divisions,
            })
        
        for _ in range(iterations):
            if current == 1:
                break
            
            if current % 2 == 0:
                # For even numbers, just divide
                k_prime = 0
                while current % 2 == 0 and current > 1:
                    current = current // 2
                    k_prime += 1
                long_steps.append({
                    'input': long_steps[-1]['result'] if long_steps else self.start,
                    'result': current,
                    'k': 0,
                    'k_prime': k_prime,
                })
            else:
                # For odd numbers, use long step
                step_info = self.compute_long_step(current)
                long_steps.append(step_info)
                current = step_info['result']
            
            if current == 1:
                break
        
        return long_steps
    
    def get_sequence_length(self) -> int:
        """
        Get the length of the sequence (number of steps to reach 1).
        
        Returns:
            Number of steps in the sequence
        """
        if 1 not in self.history:
            self.generate()
        return len(self.history) - 1  # Subtract 1 because start is included
    
    def get_max_value(self) -> int:
        """
        Get the maximum value reached in the sequence.
        
        Returns:
            Maximum value in the sequence history
        """
        if len(self.history) == 1:
            self.generate()
        return max(self.history)
    
    def get_peak_value(self) -> Tuple[int, int]:
        """
        Get the peak value and its position in the sequence.
        
        Returns:
            Tuple of (peak_value, position_index)
        """
        if len(self.history) == 1:
            self.generate()
        peak_value = max(self.history)
        peak_index = self.history.index(peak_value)
        return peak_value, peak_index

